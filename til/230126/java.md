## 변수의 종류

- 전역변수(필드) : 클래스 영역에 바로 선언하는 변수
    - 클래스 중괄호 영역 내부 전체에서 사용 가능
- 지역변수 : 클래스 영역 내의 특정 구역에 선언한 변수
    - 메소드 영역 내부, 제어문(for, if) 영역 내부 등의 블록스코프 안에서 사용하는 변수

## 전역변수(필드)

- 멤버변수(==인스턴스변수==필드)
- 클래스 변수(==static 변수)

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/4a043b09-1371-4940-b659-e1a5e2f3ab0b/Untitled.png)

static 키워드가 붙은 것들은 모두 static 영역에 할당됨(얘도 실제 데이터는 heap에 있음)

### 멤버변수와 클래스 변수 / 지역변수의 생성 및 소멸 시점

⇒ 왜 근데 static은 오버라이딩이 안될까? 왜? 그냥 얘는 새로 생기는 거 아니야??? 새로 생기는건 오케이. 그런데 ⇒ 새로 생겼으면 subClass가 출력 되어야 하는 것 아닌가??? ⇒ 변수의 타입이 superclass 니까 실제 객체에 상관없이(스테틱은 확인 안해버림) supper클래스의 

아 왜냐면 superClass로 만들었잖아~! 얘는 클래스가 

[https://woovictory.github.io/2020/07/05/Java-binding/](https://woovictory.github.io/2020/07/05/Java-binding/) 참고

지역변수가 더 우선으로 잡힌다 ⇒ 가까운 변수가 더 우선인 것인가?

지역변수에는 static이 안 붙네?

- static을 붙이면 클래스 변수이고
- static 키워드가 붙은 어떤 메소드가 있다고 했을 때, 그 안의 지역변수는 static이 안된다.
- 클래스에는 static을 붙일 수 가 없음

---

### **필드에서 사용 가능한 접근제한자**

- (+)public : 어디서든
- (#)protected : 해당 패키지 + 상속 자손일 때
    
                           **상속은 항상 아래로 단방향, 부모님께 물려주지는 않잖아
    
- (~)default : 해당 패키지
- (-)private : 해당 클래스

*클래스는 public, default만 사용 가능

** +, #, ~, - 은 [클래스 다이어그램](https://www.notion.so/230126-4b4139346d594c3f80a483244d39a7c1) 에서 사용하는 기호

---

## 클래스변수와 상수필드(static final)

클래스변수

- 선언 방법 : 접근제한자 [예약어(생략 가능)] 자료형 변수명;
- 생성 시점 : 프로그램 실행과 동시에 메모리의 static영역에 할당
- 소멸 시점 : 프로그램 종료시 소멸됨
- static : “공유”의 개념이 강하다. ⇒ 프로그램 시작부터 끝까지 쓰이는 어떤 것! static으로 만들어주는게 좋다. Math.random(), String.toString();
    
    ⇒ 두고두고 쓸 것들을 static으로 만들어두고 사용하는 것을 “싱글톤” 패턴이라고 한다. 
    

> static 키워드가 붙은 필드는 생성 후 접근할 필요 없음
단, 해당 클래스명을 앞에 반드시 명시해야함.
변수명이 중복될 때, 어떤 값을 찾아야 할지를 모르기 때문.
> 

상수필드

- 한 번 지정될 값을 고정해서 쓸 목적으로 사용
- 표현법 : public static final 자료형 변수명 = “값”;
- 예약어(static, final)의 순서는 상관없음
- 상수명은 항상 모두 대문자

```java
//대표적인 상수필드 예시
System.out.println(Math.PI);

//출력 : 3.141592653589793
```

---

# 생성자

- 표현법 : pubilc 클래스명(매개변수⇒ 생략가능) { 해당 생성자를 통해서 객체 생성시 실행하고자 하는 코드}
- 정의
    - 객체가 생성될 때, 단 한 번 호출되는 메소드
    - 메소드명이 클래스명과 동일하고 반환형이 없는 메소드
- 목적
    - 객체를 생성하기 위한 목적
    - 객체 생성 뿐 아니라 매개변수로 전달 될 값을 곧바로 필드에 초기화할 목적
- **작성시 주의사항**
    - 반드시 클래스명과 동일한 이름을 가져야 한다.
    - 반환형이 존재하지 않는다.(void와 유사…)
    - 같은 이름으로 여러개 작성이 가능하다. ⇒ **오버로딩**
        
        > 오버로딩은 매개변수가 중복되면 안된다.
        > 
    - **매개변수가 있는 생성자를 명시적으로 작성하면** 기본생성자(매개변수가 없는 생성자)가 (JVM에 의해 )자동으로 생성되지 않기 때문에 **기본 생성자 또한 명시적으로 만들어줘야 한다.** ⇒ 기본생성자는 기본적으로 만들어주는 습관을 가질 것
    
    ![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/43788100-57b5-4b3f-8fcc-84546d56c389/Untitled.png)
    
    * 생성자가 있더라도 일부 정보만을 수정하는 경우에 대비해 setter는 꼭  만들어 주도록 한다. 
    
    ![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/ab565ebc-5972-4b11-8c09-055dc48276c2/Untitled.png)
    
    ** 생성자는 매개변수의 중복 여부를 “같은 자료형의 개수”를 근거로 판단 하는 것 같다.
    
    *** 모든 필드에 대해 초기화 할 수 있는 생성자를 미리 만들어 두면 편하다.
    
    ### this 생성자로 중복코드 줄이기
    
    **Q. 생성자 안에서 또 다른 생성자의 호출이 가능하다~!?**
    
    > **this 생성자를 이용**하면 된다.
    > 
    > 
    > ![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/b0456060-3053-48d5-86c4-6a167728019e/Untitled.png)
    > 
    - 단 생성자를 생성자 안에서 호출할 때는, 호출하는 생성자의 가장 첫 줄에서 해야 한다. (그러지 않을 경우, `Constructor call must be the first statement in a constructor`애러가 발생함)
- 상수는 getter를 만들지 않는다. 상수가 꼭 static이어야 하는 법칙 같은 건 없지만 기본적으로 쓰임이 static에 알맞기 때문에 주로 static final을 쓴다.