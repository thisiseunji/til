## 배열의 복사

-----


# 배열

- 배열은 참조자료형
- 같은 자료형의 변수를 하나의 묶음으로 다룬 것
- int 배열을 만들면 모든 칸에 ⇒ int만 들어감
- 배열의 선언과 할당(배열의 크기를 지정해주는 과정을 할당이라 한다.) ⇒ 배열의 생성
    
    ```java
    자료형[] 배열명;
    
    자료형[] 배열명 = new 자료형[배열크기];
    
    int[] iArr = new int[3];
    double[] dArr = new double[3];
    
    for(int i = 0; i < iArr.length; i++) {
    			System.out.println(iArr[i]);
    }
    		
    for(int i = 0; i < iArr.length; i++) {
    			System.out.println(dArr[i]);
    }
    
    /*
    출력내용 
    0
    0
    0
    0.0
    0.0
    0.0
    
    */
    
    /*
     * 각각의 배열의 인덱스에는 값을 대입하지 않아도 값이 담겨있음
     * 메모리의 스택영역은 빈칸을 할당할 수 있지만
     * heap공간에는 절대 빈 상자가 존재할 수 없음.
     * => JVM에 의해 자료형의 기본값으로 초기화 함
     * => String 이외의 참조자료형도 null로 초기화함
     */
    ```
    
- 배열의 장점:
    - 각 자리의 인덱스를 통해 값을 할당할 수 있다.
    - 반복문을 활용할 수 있다.
    
    > 배열의 길이가 필요할 때는 `배열의이름.length`라고 함.(함수가 아님에 주의!) 
    또, 참조변수의 주소값을 10진수의 형태로 알려주는 함수도 기억할 것
    `참조변수명.hashCode();`
    > 
    
    > 배열값을 [0, 0, 0] 이런식으로 출력하고 싶을 때, `Array.toString(출력할 배열)`을 이용하면 쉽게이용할 수 있다.
    > 
- 배열의 단점 :
    - 할당 시 지정한 배열의 크기는 변경 불가능
        
        ⇒ 변경을 원할 경우, 새로운 배열을 만들어 할당해야 한다. 
        

***재할당을 통해 발생한 할당되지 않은(연결이 끊어진)  않은 힙 영역의 데이터는 일정 시간이 지나면 **가비지 컬렉터(GC)**에 의해서 삭제된다 ⇒ **가비지 컬렉션(자동 메모리 관리)** // 연결여부를 판단하여 

- 재할당 하지 않고, 그냥 연결을 끊고  싶다면? ⇒ 저장된 주소값을 지우면 되겠지? ⇒ null 값 대입

***null은 아무것도 존재하지 않음을 나타내는 “값”

연결이 끊어진 객체에 변수명을 통해 접근하려 하면, NullPointerException이 발생함

***선언만 할 경우에는 사용할 수 없음. 공간이 비어있기 때문에 ⇒ **그래서 null로 채워준다.** 

## null은 뭘까?

### **null은 어떤 값으로도 초기화되지 않은 것.**

만일 `String a = null;` 이런식으로 초기화 된 데이터가 있다면, “사용 예정”정도로 컴파일러는 생각한다. 그래서 **참조형이지만, 힙메모리 상에 데이터를 만들어내지 않는다.** 

참고 : [null이란?](https://www.notion.so/Backend-Developer-d7c8a54e535c4653b95ab673e4badda3), [JAVA - null 과 ""(빈값)의 차이는 무엇일까? / 메모리상의 차이](https://gocoder.tistory.com/1856)

> JVM에서는 null 을 객체로 본다고 한다. **null Object로**. 우리 상식선에선 '아무것도 가르키지 않는다.' 이지만 **JVM이 볼 땐 'null Object를 가르키는 참조변수이다.'** 라고 보여진다고 한다.
> 

### “”(공백)과의 차이점

공백값은 사실 하나의 스트링, `String b = “”;` 처럼 빈 값을 메모리에 할당한 것이다.

따라서 null은 사용하겠다고 예고만 해둔 상태라면 **“”는 이미 사용한 것**이다.

(실무에서는 공백으로 변수를 선언하지만 사실은 null로 하는 것이 맞다고 한다. )

### 배열의 복사

- **얕은 복사** : 배열의 **주소 값**만 복사(한 배열을 두 변수에 저장하는 것)

```java
//얕은복사

public void method1() {
		//얕은 복사
		int[] origin = {1, 2, 3, 4, 5};
		
		System.out.println("===원본 배열 출력===");
		for(int i=0; i<origin.length; i++) {
			System.out.print(origin[i]+" ");
		}
		System.out.println();
		
		int[] copy = origin;
		System.out.println("===복사본 배열 출력===");
		for(int i=0; i<copy.length; i++) {
			System.out.print(copy[i]+" ");
		}
		System.out.println();
		System.out.println();
		copy[2] = 99;
		System.out.println("origin배열에 대해 \n"
				+ "얕은 복사를 실행한 copy[2]의 값을\n"
				+ "3에서 99로 수정하였다.\n"
				+ "origin[2]의 현재값은? " + origin[2]);
		
		System.out.println();
		if (origin==copy) {
			System.out.println("origin과 copy는 같은 주소를 가리키네요.");
		}
		
	}

/*
출력 결과 :
===원본 배열 출력===
1 2 3 4 5 
===복사본 배열 출력===
1 2 3 4 5 

origin배열에 대해 
얕은 복사를 실행한 copy[2]의 값을
3에서 99로 수정하였다.
origin[2]의 현재값은? 99

origin과 copy는 같은 주소를 가리키네요.

*/
```

- **깊은 복사** : **동일한 새로운 배열**을 하나 생성해서 **실제 내부 값**들을 복사
```java
//깊은 복사
//1. for문을 이용하는 방법
public void method2( ) {
		
		int[] origin = {1,2,3,4,5};
		int sizeO = origin.length;
		int[] copy = new int[sizeO];
		
		for(int i=0; i < sizeO; i++) {
			copy[i] = origin[i];
		}
		
		if(origin != copy) {
			System.out.println("origin과 copy의 주소지는 달라요.");
		}
		
		if(Arrays.toString(origin).equals(Arrays.toString(copy))) {
			System.out.println("하지만 values는 같아요. 깊은 복사를 했기 때문이에요");
		}
		copy[2]=99;
		if(Arrays.toString(origin).equals(Arrays.toString(copy))) {
			System.out.println("하지만 values는 같아요. 깊은 복사를 했기 때문이에요");
		} else {
			System.out.println("origin[2] : " + origin[2]);
			System.out.println("copy[2] : " + copy[2]);
			System.out.println("그래서 이렇게 원본을 보존하는 수정이 가능한 것이죠!");
		}
	}
/*
출력 결과 :
origin과 copy의 주소지는 달라요.
하지만 values는 같아요. 깊은 복사를 했기 때문이에요
origin[2] : 3
copy[2] : 99
그래서 이렇게 원본을 보존하는 수정이 가능한 것이죠!
*/


```

```java

//2. System클래스에서 제공하는 arraycopy 메소드를 이용하는 방법
		int[] origin = {1,2,3,4,5};
		int[] copy = new int[10];
		//System.arraycopy(원본배열명, 원본배열의 복사시작 인덱스, 복사본 배열명, 복사할 배열 기준으로 복사될 시작 인덱스, 복사할 갯수)
		//자바에서 배열 복사만을 위해 제공하는 함수라 배열 복사방법 중 효율이 제일 좋다.
		System.arraycopy(origin, 0, copy, 0, 5);
		System.out.println(Arrays.toString(copy));
/*
[1, 2, 3, 4, 5, 0, 0, 0, 0, 0]
*/

```

```java
//3.Arrays 클래스의 copyOf메소드를 이용하는 방법
public void method4() {
		int[] origin = {1,2,3,4,5};
		//3.Arrays 클래스의 .copyOf메소드를 이용하는 방법
		// 복사본 배열 = Arrays.copyOf(원본배열명, 복사할 값의 갯수);
		// 복사하고싶은 배열의 크기보다 더 큰 값을 입력해도 된다. 
		
		int[] copy = Arrays.copyOf(origin, 10);
		System.out.println(Arrays.toString(copy));
	}

```

```java
//4. 원본배열명.clone()
public void method5() {
		//4. 원본배열명.clone();
		//배열의 크기를 변경할 수 없다.
		int[] origin = {1,2,3,4,5};
		int[] copy = origin.clone();
		
		System.out.println("copy : "+ Arrays.toString(copy));
	}
```
--------
## 상속

# 상속

## 상속이란?

기존 클래스에 기능을 추가하거나 재정의하여 새로운 클래스를 정의하는 것을 의미

이러한 상속은 캡슐화, 추상화와 더불어 객체 지향 프로그래밍을 구성하는 중요한 특징 중 하나이다. 

상속을 이용하면 기존에 정의되어있던 클래스의 모든 필드와 메소드를 물려받아 새로운 클래스를 생성할 수 있으며, 이때 기존 클래스를 부모,상위,기초 클래스라고 할 수 있고, 상속을 통해 새롭게 작성되는 클래스를 자식, 하위, 파생 클래스라고 한다. 

### 장점

1. 기존에 작성된 클래스를 재활용할 수 있습니다.
2. 자식 클래스 설계 시 중복되는 멤버를 미리 부모 클래스에 작성해 놓으면, 자식 클래스에서는 해당 멤버를 작성하지 않아도 됩니다.
3. 클래스 간의 계층적 관계를 구성함으로써 다형성의 문법적 토대를 마련합니다.

- 자식클래스의 선언

```
class 자식클래스 이름 **extends** 부모클래스 이름 ****{} 
```

- 자식 클래스에는 부모 클래스의 **필드와 메소드만**이 **상속**
- **생성자**와 **초기화 블록**은 상속되지 않는다.
- 부모 클래스의 접근 제어가 **private이나 default로 설정된 멤버**는 자식 클래스에서 **상속받지만 접근할 수는 없다.**
- 자바에서 클래스는 단 한 개의 클래스만을 상속받는 **단일 상속만이 가능**하다.

### Object 클래스

모든 클래스의 부모 클래스가 되는 클래스.

별도로 extends 키워드를 사용하지 않아도 Object 클래스의 모든 멤버를 자유롭게 사용할 수 있다.

(toString(), clone()과 같은 메소드를 바로 사용할 수 있는 이유가 해당 메소드들이 object클래스의 메소드이기 때문)

## super와 super()

### super : 자신이 상속받은 부모를 가리키는 참조변수

- **부모 클래스로부터 상속받은 필드나 메소드를 자식 클래스에서 참조하는 데 사용**하는 **참조 변수**이다.
- **인스턴스 변수와 지역변수의 이름이 같을 때**, 변수 앞에 **this**키워드를 사용하여 구분하듯이
- **부모클래스의 멤버와 자식 클래스의 멤버 이름이 같을 경우,** **super**키워드를 사용하여 구별할 수 있다.
- (**[this와 마찬가지로)](https://www.notion.so/230119-3f8972d0447940f394650b1bc66b9b12) super 참조변수를 사용할 수 있는 대상도 인스턴스 메소드 뿐이며, 클래스 메소드에서는 사용할 수 없다.** ⇒ 이유를 생각해보면, super는 결국 부모의 인스턴스변수를 가리키는 참조변수 일 뿐임. 클래스 메소드에서 super을 사용한다면, 인스턴스 멤버는 아예 생성되지 않았기 때문에 가리킬 수 없을 가능성이 존재하기 때문. (내가 이해한 바로는 이렇다.)

### super() : 자신이 상속받은 부모의 생성자를 호출하는 메소드

- 자식클래스가 인스턴스화 되면, 인스턴스 안에는 자식클래스의 멤버 + 생성자를 제외한! 부모 클래스의 멤버가 모두 존재한다.
- 하지만, **상속에서의 생성자는 상속되지 않는 유일한 멤버함수다**. 따라서 부모클래스의 멤버를 초기화하기 위해서는 당연히 부모 클래스의 생성자를 호출해야 할 것이다.
- 즉 자식클래스의 생성자를 호출할 때, 부모 클래스의 생성자도 동시에 호출해야한다. (정확히 말하면 부모클래스의 생성자가 먼저 호출되는 거지만…!)

> 부모클래스에 기본생성자만 있다면, 자식클래스 생성자를 호출할 때 super()를 자바 컴파일러가 자동으로 추가해준다. 하지만! 부모클래스에서 오버로딩 된 생성자만 있을 경우 오류가 발생한다. 따라서 매개변수를 가지는 생성자를 선언해야 할 경우에는 되도록 기본생성자까지 명시적으로 선언하는 것이 좋다.
> 

***부모클래스 생성자를 호출하는 행위는 맨 처음 조상인 Object 클래스까지 올라간다. 

---

## method overriding(다시 공부해야하겠다.)

- 정의 : 부모클래스에서 정의된 메소드를 자식클래스에서 같은 시그니쳐를 갖는 메소드로 재정의 하는 것.
- 오버라이딩 조건:
    - 메소드 선언부는 기존 메소드와 완전히 같아야 한다. (메소드의 반환타입은 부모클래스의 반환타입으로 변환할 수 있는 타입이라면 변경할 수 있다 ⇒ 같은 부모의 자식으로 가능(다형성 인가?)
    - 부모 클래스의 메소드보다 접근제어자를 더 좁은 범위로 변경할 수 없다. (왜냐하면 자식-자식 클래스에서도 계속해서 상속해서 사용할 수 있도록 해야하니까?)
    - 부모 클래스의 메소드보다 더 큰 범위의 예외를 선언할 수 없다. (이유가 뭘까?)
    - static 메소드는 오버라이딩이 불가하다. ⇒ static hiding이라고 함.
        - 부모 클래스와 자식클래스의 동일한 이름의 정적 메서드는 재정의가 아닌 새로 추가된 것이며 서로 구별된다.
        - static메소드는 컴파일 시, 메모리에 올라가고 메소드 영역에 존재하며, 실제 객체를 찾는 작업을 실행하지 않는다. ⇒ 컴파일 시점에 선언된 타입의 메소드를 호출
        - 오버라이딩은 런타임 시, 사용도리 메소드를 결정한다.
        - static은 클래스 단위의 성격, 오버라이딩은 객체단위의 성격을 지닌다.
        - 따라서, static 메소드는 오버라이딩이 불가능하다.

# [링크](https://minni7.tistory.com/32) 참고해서 다시 공부!!