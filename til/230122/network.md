## 네트워크 인터페이스 선택 원리와 기준
    - 네트워크 인터페이스가 2개 이상 연결되어있을 때(라우팅 테이블에 동일 대상에 대한 다수의 경로가 등록되어 있을 때 라고 표현해도 될까?) 선택의 기준은 메트릭 값이다.
    - 메트릭 값은 = 비용
    - 속도가 빠를 수록 메트릭값이 적게 할당된다.
  
------

## web 탄생 배경

- 창시자 : 티모시 버너스 리(팀 버너스리)

CERN(입자물리연구소)에서 팀 버너스리님이 연구원으로 일하던 당시의 컴퓨터는 문자를 text파일로 저장하는 형태로 되어있었음. 그는 연구원이었으므로, 논문을 자주 읽었는데, 논문의 마지막은 늘 참고문헌으로 마무리 되었다. 텍스트 파일에는 “링크”의 개념이 존재하지 않았기 때문에 늘 논문을 검색해서 읽어야 했다.

그래서 팀 버너스리는 정보와 링크를 구별하기 위해 HTML이라는 문서 형식을 고안하고, 인터넷 기술을 활용해서 연결(즉 전달)하는 방법을 생각해서 HTTP라는 프로토콜을 만들어낸다.  

- text문서 + 링크 ⇒ 확장, 연결

이런 문서와의 연결을 그림으로 표현하니 마치 거미줄 같았고, “Web”이라 부르게 되었다. 

모든 문서를 다루기 위한 소프트웨어는 

1. 인터페이스(유저 인터페이스)
2. 제어 체계(문서를 처리하기 위한 로직)
3. 데이터

로 구성되어있다. 이 모든것을 구현한 것
------
## 초창기 웹 서비스 구조
    
    프로그램은 보통 
    
    1. 자료구조
    2. UI
    3. 제어체계로 이뤄진다. 
    
    유지보수의 편의성을 극대화 하기 위해 최소한 이 3가지 개념으로 모듈화가 이뤄진다. 
    
    웹 또한 마찬가지.
    
    HTTP는 1.0, 1.1, 2.0.을 거쳐 3.0 까지 왔지만, 90년대부터 가장 많이 사용되는 것은 1.1(현재는 2.0으로 빠르게 넘어가고 있는 상태). 1.1 기준으로 설명을 시작한다. 
    
    (HTTP를 고안할 때, TCP/IP 연결이 되어있다고 가정하고, 이 연결을 기초로 HTTP통신이 되는 것)
    
    > TCP연결은 상태의 개념을 포함하는데,  HTTP는 Stateless하다.
    > 
    
    ![스크린샷 2023-01-22 오후 4.18.17.png](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/d820d0c4-983b-4092-98ed-4d2f835a56db/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2023-01-22_%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE_4.18.17.png)
    
    웹을 이루는 구성요소로 웹 클라이언트(브라우저)가 있다. 위의 사진에서처럼 인터넷을 거쳐 웹 서버로 연결된다. 
    
    서버에 있는 논문(HTML문서 형식, Resource)를 가져오기 위해, 브라우저에 주소(URL : ***Uniform Resource Locator)***를 입력하면, DNS서버를 거쳐 서버 IP주소로 연결 된 후, TCP/IP연결이 진행되고, 리소스에 대한 요청이 간다. 
    
    HTTP프로토콜의 작동 순서는…
    
    리퀘스트를 보내는데, 리퀘스트가 가면, http구조상 리스폰스가 오게 되어있음. 
    
    리퀘스트에는 여러가지 방법(method)이 있는데, 가장 만만한게… GET이니까 “리소스주세요!” 요청을 하면 그에 따른 html문서를 준다. 고로 GET은 클라이언트 입장에서 보면 Read요청이 되는 것. 
    
    여튼, 이렇게 받아온 http문서는 Tag로 되어있다. 
    
    브라우저는 http문서에 대한 
    
    4. 구문분석(파싱)을 통해 어떤 내용을 페이지에 렌더링 할지 결정한다. → 비선형 트리형태의 자료구조를 생성([DOM](https://wit.nts-corp.com/2019/02/14/5522): 웹 페이지에 대한 인터페이스로, 브라우저가 렌터 트리를 생성하기 위해 필요한 모델이다. html 요소들의 구조화된 표현이 DOM이고, CSSOM이 요소들과 연관된 스타일 정보의 구조화된 표현을 나타낸다. ) 
    5. 해당 렌더링을 수행한다. 
    
    > **DOM은 어떻게 생성되고 보여질까?**
    DOM은 원본 HTML 문서의 객체 기반 표현 방식입니다. 둘은 서로 비슷하지만, DOM이 갖고 있는 근본적인 차이는 단순 텍스트로 구성된 HTML 문서의 내용과 구조가 객체 모델로 변환되어 다양한 프로그램에서 사용될 수 있다는 점입니다.
    > 
    > 
    > DOM의 개체 구조는 “노드 트리”로 표현됩니다. 하나의 부모 줄기가 여러 개의 자식 나뭇가지를 갖고 있고, 또 각각의 나뭇가지는 잎들을 가질 수 있는 나무와 같은 구조로 이루어져 있기 때문입니다. 이 케이스의 경우, 루트 요소인 `html`은 “부모 줄기”, 루트 요소에 내포된 태그들은 “자식 나뭇가지” 그리고 요소 안의 컨텐츠는 “잎”에 해당합니다.
    > 
    
    즉 브라우저의 핵심은 구문분석기와, 렌더링 엔진이었다. 이때의 브라우저는 “원격지 문서뷰어”의 역할을 한 것.
-----
## 웹 서비스의 3대 요소
문서를 가져와서 보여주고, 문서 안의 하이퍼링크를 통해, 또 다른 요청과 응답이 반복되는 상황.

현재까지는 서버에서 일방적으로 정보를 전달하는 “단방향 작용”이 일어나는 단계이다. 

> 프로그램은 보통
> 
> 1. 자료구조
> 2. UI
> 3. 제어체계로 이뤄진다.

현재 상황이 1번(HTML)은 어느정도 만족 된 상태기 때문에그렇다면 2번을 분리해서 개선시키는데, 그게 CSS. 

서버에 연결되면 실제로 HTML + CSS + 이미지 자료의 순으로 클라이언트에 전달된다. 

이 때 서버에는  HTML + CSS + 이미지가 저장되어있는 상태 → 정적

…

추후 시간이 흐르고 웹이 더욱 발전하여 문서를 갱신하거나, 로그인 등 클라이언트에서 입력한 정보를 통해 어떤 처리를 해야하는 상황이 생긴다. ⇒ 양방향 상호작용

그래서 웹서버에는 연산 처리를 하는 기능이 분리되어 추가된다. 

![스크린샷 2023-01-22 오후 5.20.57.png](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/067c2b3e-f8a4-47d7-ad5b-63cb94078713/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2023-01-22_%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE_5.20.57.png)

양방향 상호작용으로 웹이 발전하면서 문맥이 발생한다. 상태→ 전이의 개념이 나타난 것.

문제는 http가 Stateless 하기 때문에 상태와 전이를 기록할 방법이 없다. ⇒ 이 문제를 해결하기 위해 연산 서버 뒤쪽으로 데이터베이스가 추가된다. 

디비와 연산서버는 언어에 따라 연결 방법은 다르지만, 연결 이후에 SQL을 매체로 소통한다. 

여튼 연산 서버가 DB를 통해 데이터를 가져와서 이미 서버에 저장되어있는 정적인 문서가 아니라 연산 처리 결과에 따라 동적으로 또 다른 문서를 생성하여 반환하는 경우도 발생 한다. 

(예를 들어 tester라는 id로 로그인에 성공하면 tester님, 안녕하세요 라는 문서를 보여줄 수 있는 것처럼.)

브라우저에서 역시 “연산”이 가능한 엔진을 추가하게 된다. 

웹 초창기 시절 이런 연산기능을 스크립트 언어로 구현하게 되는데, Mocha → Live → JavaScript로 언어의 이름이 바뀌게 된다. 

**“자바스크립트”는 그 본질에 따라 실행을 클라이언트 브라우저에서 한다.** 

작성된 자바스크립트 파일은 정적인 파일에 포함되어 웹 브라우저 클라이언트로 전달된다.  

HTML + CSS + 이미지(정적파일) + JS파일

정리해서 클라이언트 웹 브라우저를 이루는 3요소가 무엇이냐고 한다면, 

1. 파서(DOM생성)
2. 렌더링 엔진
3. 스크립트 엔진

브라우저의 성능은 이 세가지로 측정된다. 

서버단의 기억(기록)이 디비로 구현되었다면, 클라이언트 단의 기억은 어떤 것으로 구현되었을까? ⇒ Cookie

쿠키는 [key+value]에 여러가지 속성(범위+기간 등)이 추가된 형태